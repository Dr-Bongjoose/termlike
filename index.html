<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROOT_ACCESS // TERMINAL_UPLINK</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        :root {
            --phosphor-main: #33ff00;
            --phosphor-dim: #1a8000;
            --phosphor-alert: #ff3333;
            --phosphor-exec: #ffaa00;
            --bg-color: #050505;
            --scanline-color: rgba(0, 0, 0, 0.5);
        }

        body {
            background-color: #000;
            color: var(--phosphor-main);
            font-family: 'VT323', monospace;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            text-shadow: 0 0 5px var(--phosphor-dim), 0 0 10px var(--phosphor-dim);
            cursor: text;
            transition: color 0.5s ease, text-shadow 0.5s ease;
        }

        /* CRT Monitor Frame */
        #monitor {
            width: 100%;
            height: 100%;
            max-width: 1024px;
            max-height: 768px;
            background-color: var(--bg-color);
            border-radius: 20px;
            position: relative;
            box-shadow: 0 0 50px rgba(51, 255, 0, 0.1);
            overflow: hidden;
            border: 2px solid #333;
            transition: box-shadow 0.5s ease;
        }

        /* Screen Curvature & Vignette */
        #screen-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.6) 100%);
            pointer-events: none;
            z-index: 10;
            border-radius: 20px;
        }

        /* Scanlines */
        #scanlines {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 9;
            animation: scroll 10s linear infinite;
        }

        /* Terminal Content Area */
        #terminal {
            padding: 40px;
            height: 100%;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            font-size: 1.5rem;
            line-height: 1.2;
            overflow-y: auto;
        }

        #output {
            flex-grow: 1;
            white-space: pre-wrap;
            overflow-y: auto;
            margin-bottom: 20px;
            scrollbar-width: none;
        }
        #output::-webkit-scrollbar { display: none; }

        #input-line {
            display: flex;
            align-items: center;
        }

        #prompt {
            margin-right: 10px;
            color: var(--phosphor-main);
            transition: color 0.5s ease;
        }

        #cmd-input {
            background: transparent;
            border: none;
            color: var(--phosphor-main);
            font-family: 'VT323', monospace;
            font-size: 1.5rem;
            outline: none;
            flex-grow: 1;
            text-shadow: inherit;
            transition: color 0.5s ease;
        }

        /* Classes */
        .glitch-text { animation: glitch 1s infinite; color: var(--phosphor-alert); }
        .system-msg { color: #fff; opacity: 0.8; }
        .error-msg { color: var(--phosphor-alert); }
        .file-dir { color: #fff; font-weight: bold; }
        .file-exec { color: var(--phosphor-exec); }
        .scanned-safe { color: #fff; opacity: 0.5; }
        .scanned-trap { color: var(--phosphor-alert); font-weight: bold; }
        .scanned-corrupt { color: #ff00ff; font-weight: bold; text-shadow: 0 0 5px #ff00ff; }
        .progress-bar { color: var(--phosphor-exec); }
        .watchdog-warning { color: var(--phosphor-alert); font-weight: bold; animation: pulse 0.5s infinite; }
        .trait-text { color: var(--phosphor-exec); font-style: italic; }
        
        .damage-flash { animation: flashRed 0.2s ease-out; }
        .watchdog-flash { animation: flashRed 1s infinite; }

        /* Minigame Overlay */
        #minigame-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            background: rgba(0,0,0,0.9);
            border: 2px solid var(--phosphor-main);
            padding: 20px;
            text-align: center;
            display: none;
            z-index: 20;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }
        .hex-code { font-size: 2rem; letter-spacing: 5px; margin: 20px 0; }
        .hex-match { color: var(--phosphor-main); }
        .hex-target { color: #555; }

        @keyframes flashRed {
            0% { box-shadow: inset 0 0 100px var(--phosphor-alert); }
            50% { box-shadow: inset 0 0 20px var(--phosphor-alert); }
            100% { box-shadow: none; }
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }

        @keyframes scroll {
            0% { background-position: 0 0; }
            100% { background-position: 0 100%; }
        }

        #hud {
            position: absolute;
            top: 20px;
            right: 40px;
            text-align: right;
            z-index: 5;
        }
        
        #scan-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0;
            pointer-events: none;
            z-index: 8;
        }
    </style>
</head>
<body>

<div id="monitor">
    <div id="scanlines"></div>
    <div id="screen-overlay"></div>
    <div id="scan-line"></div>
    
    <!-- Minigame UI -->
    <div id="minigame-overlay">
        <div style="font-size: 1.5rem; margin-bottom: 10px;">DECRYPTION SEQUENCE</div>
        <div id="hex-display" class="hex-code"></div>
        <div id="minigame-timer" style="width: 100%; height: 5px; background: #333; margin-top: 10px;">
            <div id="minigame-bar" style="width: 100%; height: 100%; background: var(--phosphor-main);"></div>
        </div>
        <div>TYPE THE CODE</div>
    </div>

    <div id="hud">
        <div>STABILITY: <span id="stability-val">100%</span></div>
        <div>CREDITS: <span id="credits-val">0</span></div>
        <div style="color: var(--phosphor-exec);">DEBT: <span id="debt-val">5000</span></div>
        <div>JOB: <span id="job-val">NONE</span></div>
        <div style="font-size: 0.8em; opacity: 0.8;" id="trait-val"></div>
        <div style="margin-top: 10px; opacity: 0.7; font-size: 0.8em;">SYSTEM: <span id="hw-val">CPU:0 RAM:0 NET:0</span></div>
        <div style="margin-top: 5px; opacity: 0.7; font-size: 0.8em;">TOOLS: <span id="tools-val">NONE</span></div>
    </div>

    <div id="terminal">
        <div id="output"></div>
        <div id="input-line">
            <span id="prompt">user@root:~$</span>
            <input type="text" id="cmd-input" autocomplete="off" autofocus>
        </div>
    </div>
</div>

<script>
    /**
     * ROOT_ACCESS PROTOTYPE v0.9
     * Features: Hardware Upgrades, .bashrc (Auto-LS), Scanner Fix
     */

    // --- AUDIO ENGINE ---
    const AudioEngine = {
        ctx: null,
        init: function() {
            if (!this.ctx) {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (this.ctx.state === 'suspended') this.ctx.resume();
        },
        playTone: function(freq, type, duration, vol = 0.1) {
            if (!this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        },
        playNoise: function(duration, vol = 0.1) {
            if (!this.ctx) return;
            const bufferSize = this.ctx.sampleRate * duration;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;
            const gain = this.ctx.createGain();
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
            noise.connect(gain);
            gain.connect(this.ctx.destination);
            noise.start();
        },
        sfx: {
            type: () => AudioEngine.playTone(800 + Math.random()*200, 'square', 0.05, 0.05),
            enter: () => AudioEngine.playTone(400, 'square', 0.1, 0.1),
            error: () => AudioEngine.playTone(150, 'sawtooth', 0.3, 0.2),
            success: () => {
                AudioEngine.playTone(1200, 'sine', 0.1, 0.1);
                setTimeout(() => AudioEngine.playTone(1800, 'sine', 0.2, 0.1), 100);
            },
            glitch: () => {
                AudioEngine.playNoise(0.2, 0.2);
                AudioEngine.playTone(50, 'sawtooth', 0.2, 0.2);
            },
            process: () => AudioEngine.playTone(600, 'square', 0.05, 0.05),
            connect: () => {
                let t = 0;
                const interval = setInterval(() => {
                    AudioEngine.playTone(200 + Math.random()*1000, 'square', 0.05, 0.1);
                    t++;
                    if (t > 10) clearInterval(interval);
                }, 50);
            },
            win: () => {
                AudioEngine.playTone(440, 'sine', 0.2, 0.2);
                setTimeout(() => AudioEngine.playTone(554, 'sine', 0.2, 0.2), 200);
            },
            alarm: () => {
                AudioEngine.playTone(2000, 'sawtooth', 0.1, 0.15);
                setTimeout(() => AudioEngine.playTone(2000, 'sawtooth', 0.1, 0.15), 150);
            },
            minigameHit: () => AudioEngine.playTone(1000, 'square', 0.05, 0.1),
        }
    };

    // --- GAME DATA ---

    const FILESYSTEM_TEMPLATE = {
        "home": {
            type: "dir",
            content: {
                "contract.txt": { type: "file", content: "EMPLOYEE #4491\nCURRENT DEBT: 5000 CR\n\nREMINDER: Interest is compounded daily." },
                "tips.txt": { type: "file", content: "LEVEL 2+ WARNING: Corruption disguises itself as system files. SCAN EVERYTHING.\n\nPRO TIP: Buy ROOT_KIT for Auto-LS." }
            }
        },
        "bin": {
            type: "dir",
            content: {
                "purge.exe": { type: "exec", desc: "Removes corruption entities." },
                "scan.exe": { type: "exec", desc: "Reveals hidden file properties." },
                "unlock.exe": { type: "exec", desc: "Unlocks directory with password code." },
                "pay.exe": { type: "exec", desc: "Transfer credits to Debt Ledger." },
                "shop.exe": { type: "exec", desc: "Access the Black Market." }
            }
        }
    };

    const THEMES = {
        RESEARCH: {
            color: "#00ffff", dim: "#008888",
            files: ["subject_89.log", "bio_containment.chk", "gene_seq.dat", "autopsy.rep"],
            decoys: ["lab_temp.dat", "waste_log.txt", "centrifuge.sys", "sample_01.bak"],
            logs: ["It's breathing.", "Samples merging.", "Evacuate lab."],
            corrupt: ["BIOMASS", "NERVE", "EYE"]
        },
        MILITARY: {
            color: "#ff5555", dim: "#882222",
            files: ["drone_uplink.bin", "target_list.enc", "casualty.txt", "nuke_codes.dat"],
            decoys: ["ammo_inv.db", "drill_sched.txt", "latrine.log", "radar_cal.sys"],
            logs: ["Friendly fire.", "AI refusal.", "Silo stuck."],
            corrupt: ["ROGUE_AI", "KILL_SWITCH", "WARHEAD"]
        },
        FINANCE: {
            color: "#ffd700", dim: "#886600",
            files: ["ledger.csv", "crash.sim", "offshore.db", "audit.log"],
            decoys: ["payroll.dat", "stocks.bak", "tax_evade.tmp", "printer.cfg"],
            logs: ["Who moved funds?", "Bleeding numbers.", "Sell all."],
            corrupt: ["VOID_TX", "SIPHON", "GREED"]
        }
    };

    const TRAITS = [
        { name: "STANDARD", desc: "Nominal operation.", stabilityMod: 1.0, purgeCost: 1.0 },
        { name: "HARDENED", desc: "Security active. Purge costs double.", stabilityMod: 1.0, purgeCost: 2.0 },
        { name: "FRAGILE", desc: "Old Hardware. Stability drains fast.", stabilityMod: 2.0, purgeCost: 1.0 },
        { name: "LEAKY", desc: "Data loose. Scanning is instant.", stabilityMod: 1.0, purgeCost: 1.0, instantScan: true },
        { name: "GHOSTED", desc: "High paranoia. Watchdogs likely.", stabilityMod: 1.0, purgeCost: 1.0, watchdogChance: 0.8 }
    ];

    // UPDATED SHOP: Now includes Hardware (Stackable) and Software
    const SHOP_ITEMS = {
        "decryption_module": { cost: 100, desc: "Unlocks encrypted corruption files.", type: "tool" },
        "scanner_v2": { cost: 200, desc: "Auto-detects traps on entry.", type: "passive" },
        "root_kit": { cost: 300, desc: "Installs .bashrc with Auto-LS.", type: "passive" },
        "cpu_upgrade": { cost: 500, desc: "Speeds up all actions (Stackable).", type: "hardware", stat: "cpu" },
        "ram_upgrade": { cost: 400, desc: "+Stability & Regen (Stackable).", type: "hardware", stat: "ram" },
        "net_card": { cost: 400, desc: "Reduces Command Cost (Stackable).", type: "hardware", stat: "net" },
    };

    class GameState {
        constructor() {
            this.currentPath = ["home"];
            this.fileSystem = JSON.parse(JSON.stringify(FILESYSTEM_TEMPLATE));
            this.stability = 100;
            this.maxStability = 100;
            this.credits = 0;
            this.debt = 5000;
            this.connected = false;
            this.inventory = [];
            
            // New Hardware Stats
            this.hardware = { cpu: 0, ram: 0, net: 0 };
            
            this.difficulty = 1;
            this.isBusy = false;
            this.activeAction = null;
            this.currentTheme = null;
            this.currentTrait = TRAITS[0];
            
            this.minigameActive = false;
            this.minigameTarget = "";
            this.minigameInput = "";
            this.minigameTimer = null;
            this.minigameCallback = null;

            this.watchdogTimer = null;
            this.watchdogInterval = null;
        }

        save() {
            localStorage.setItem('root_access_save', JSON.stringify({
                credits: this.credits,
                debt: this.debt,
                inventory: this.inventory,
                hardware: this.hardware
            }));
        }

        load() {
            const data = localStorage.getItem('root_access_save');
            if (data) {
                const parsed = JSON.parse(data);
                this.credits = parsed.credits || 0;
                this.debt = parsed.debt !== undefined ? parsed.debt : 5000;
                this.inventory = parsed.inventory || [];
                this.hardware = parsed.hardware || { cpu: 0, ram: 0, net: 0 };
                this.updateStats();
            }
        }
        
        updateStats() {
            // RAM increases max stability
            this.maxStability = 100 + (this.hardware.ram * 50);
        }
    }

    const state = new GameState();
    state.load();

    const outputDiv = document.getElementById('output');
    const inputField = document.getElementById('cmd-input');
    const stabilityVal = document.getElementById('stability-val');
    const promptSpan = document.getElementById('prompt');

    // --- UTILS ---

    function setTheme(themeKey) {
        const root = document.documentElement;
        if (!themeKey) {
            root.style.setProperty('--phosphor-main', '#33ff00');
            root.style.setProperty('--phosphor-dim', '#1a8000');
            document.getElementById('monitor').style.boxShadow = "0 0 50px rgba(51, 255, 0, 0.1)";
        } else {
            const theme = THEMES[themeKey];
            root.style.setProperty('--phosphor-main', theme.color);
            root.style.setProperty('--phosphor-dim', theme.dim);
            document.getElementById('monitor').style.boxShadow = `0 0 50px ${theme.color}20`;
        }
    }

    function triggerDamageFlash(persistent = false) {
        const overlay = document.getElementById('screen-overlay');
        overlay.className = persistent ? 'watchdog-flash' : 'damage-flash';
        if(!persistent) setTimeout(() => overlay.className = '', 200);
    }

    function findFileKey(dir, filename) {
        if (!filename) return null;
        if (dir[filename]) return filename; 
        const lowerName = filename.toLowerCase();
        return Object.keys(dir).find(k => k.toLowerCase() === lowerName) || null;
    }

    function print(text, type = 'normal') {
        const line = document.createElement('div');
        if (type === 'error') line.classList.add('error-msg');
        if (type === 'system') line.classList.add('system-msg');
        if (type === 'glitch') line.classList.add('glitch-text');
        if (type === 'progress') line.classList.add('progress-bar');
        if (type === 'warning') line.classList.add('watchdog-warning');
        if (type === 'trait') line.classList.add('trait-text');
        
        line.innerText = text;
        outputDiv.appendChild(line);
        outputDiv.scrollTop = outputDiv.scrollHeight;
        return line;
    }

    function updateHUD() {
        // Show max stability (RAM Upgrade)
        stabilityVal.innerText = Math.floor(state.stability) + "/" + state.maxStability;
        
        if (state.stability < 30) stabilityVal.style.color = "var(--phosphor-alert)";
        else stabilityVal.style.color = "inherit";

        document.getElementById('credits-val').innerText = state.credits;
        document.getElementById('debt-val').innerText = state.debt;
        
        // Show Hardware Levels
        document.getElementById('hw-val').innerText = `CPU:${state.hardware.cpu} RAM:${state.hardware.ram} NET:${state.hardware.net}`;
        
        let jobText = "NONE";
        if (state.connected) {
            jobText = `${state.currentTheme} (LVL ${state.difficulty})`;
            document.getElementById('trait-val').innerText = `[${state.currentTrait.name}]`;
        } else {
            document.getElementById('trait-val').innerText = "";
        }
        document.getElementById('job-val').innerText = jobText;
        
        const toolList = state.inventory.length > 0 ? state.inventory.map(i => i.split('_')[0]).join(', ') : "NONE";
        document.getElementById('tools-val').innerText = toolList.toUpperCase();
        
        promptSpan.innerText = state.connected 
            ? `admin@${state.currentTheme.toLowerCase()}:/${state.currentPath.join('/')}$` 
            : `user@root:/${state.currentPath.join('/')}$`;
        
        if (state.isBusy || state.minigameActive) {
            inputField.style.opacity = "0.2";
        } else {
            inputField.style.opacity = "1";
        }
    }

    function getCurrentDir() {
        let current = state.fileSystem;
        for (let folder of state.currentPath) {
            if (current[folder] && current[folder].type === 'dir') {
                current = current[folder].content;
            }
        }
        return current;
    }

    // --- RECURSIVE FOLDER GENERATOR ---
    function generateDeepStructure(depth, themeData, difficulty) {
        if (depth <= 0) return {};

        const folders = {};
        // Random number of subfolders (1-3)
        const subFolderCount = Math.max(1, Math.floor(Math.random() * 3));
        const folderNames = ["var", "opt", "usr", "temp", "cache", "logs", "bin", "data", "backup", "spool"];

        for (let i = 0; i < subFolderCount; i++) {
            const name = folderNames[Math.floor(Math.random() * folderNames.length)] + "_" + Math.floor(Math.random() * 99);
            // Recursive call
            folders[name] = {
                type: "dir",
                content: generateDeepStructure(depth - 1, themeData, difficulty)
            };
        }
        return folders;
    }

    function injectTargetIntoRandomFolder(root, fileKey, fileObj) {
        // Simple BFS to find all folders
        let directories = [];
        let queue = [{path: [], content: root}];
        
        while(queue.length > 0) {
            let current = queue.shift();
            directories.push(current.content);
            
            for(let key in current.content) {
                if(current.content[key].type === 'dir') {
                    queue.push({path: [...current.path, key], content: current.content[key].content});
                }
            }
        }
        
        // Pick random folder (avoid root if possible)
        if(directories.length > 1) directories.shift(); 
        const targetDir = directories[Math.floor(Math.random() * directories.length)];
        targetDir[fileKey] = fileObj;
    }

    // --- ACTION SYSTEM ---
    function startAction(label, durationSec, onComplete) {
        if (state.isBusy) return;
        state.isBusy = true;
        updateHUD();

        // CPU Upgrade reduces duration (15% per level, max 75%)
        const cpuBonus = Math.min(0.75, state.hardware.cpu * 0.15);
        const adjustedDuration = durationSec * (1.0 - cpuBonus);

        print(`INITIATING ${label}...`, "system");
        const progressLine = print("[....................] 0%", "progress");
        
        const totalSteps = 20;
        let currentStep = 0;
        const intervalTime = (adjustedDuration * 1000) / totalSteps;

        state.activeAction = setInterval(() => {
            currentStep++;
            const pct = Math.floor((currentStep / totalSteps) * 100);
            
            const filled = Math.min(Math.max(0, currentStep), totalSteps);
            const empty = Math.min(Math.max(0, totalSteps - currentStep), totalSteps);
            const bars = "=".repeat(filled) + ".".repeat(empty);
            
            progressLine.innerText = `[${bars}] ${pct}%`;
            
            if (AudioEngine.sfx.process) AudioEngine.sfx.process();

            if (currentStep >= totalSteps) {
                clearInterval(state.activeAction);
                state.isBusy = false;
                state.activeAction = null;
                updateHUD();
                onComplete();
            }
        }, intervalTime);
    }

    function abortAction() {
        if (state.activeAction) {
            clearInterval(state.activeAction);
            state.activeAction = null;
            state.isBusy = false;
            print("ACTION ABORTED BY USER.", "error");
            updateHUD();
        } else {
            print("No active process to abort.", "system");
        }
    }

    // --- MINIGAME SYSTEM ---
    function startDecryptMinigame(difficulty, onSuccess) {
        state.minigameActive = true;
        state.minigameInput = "";
        
        const len = 3 + Math.floor(difficulty);
        let chars = "0123456789ABCDEF";
        let target = "";
        for(let i=0; i<len; i++) {
            target += chars[Math.floor(Math.random()*16)] + chars[Math.floor(Math.random()*16)];
        }
        state.minigameTarget = target;
        state.minigameCallback = onSuccess;

        const overlay = document.getElementById('minigame-overlay');
        overlay.style.display = 'block';
        updateMinigameUI();

        // CPU Upgrade helps slightly with timer too? No, keep it skill based.
        const timeLimit = 12000; 
        const start = Date.now();
        state.minigameTimer = setInterval(() => {
            const elapsed = Date.now() - start;
            const pct = 100 - ((elapsed / timeLimit) * 100);
            document.getElementById('minigame-bar').style.width = pct + "%";
            
            if (elapsed >= timeLimit) {
                endMinigame(false);
            }
        }, 50);
    }

    function updateMinigameUI() {
        const display = document.getElementById('hex-display');
        let html = "";
        const pairs = state.minigameTarget.match(/.{1,2}/g);
        
        let charIndex = 0;
        for(let pair of pairs) {
            let pairClass = "hex-target";
            if (state.minigameInput.length >= charIndex + 2) {
                pairClass = "hex-match";
            }
            html += `<span class="${pairClass}">${pair}</span> `;
            charIndex += 2;
        }
        display.innerHTML = html;
    }

    function endMinigame(success) {
        clearInterval(state.minigameTimer);
        state.minigameActive = false;
        document.getElementById('minigame-overlay').style.display = 'none';
        
        if (success) {
            AudioEngine.sfx.success();
            if(state.minigameCallback) state.minigameCallback();
        } else {
            AudioEngine.sfx.error();
            print("DECRYPTION FAILED. KEY INVALID.", "error");
            state.stability -= 10;
            triggerDamageFlash();
            updateHUD();
        }
    }

    // --- WATCHDOG ---
    function triggerWatchdog() {
        if (state.watchdogInterval) return;
        
        print("!!! WARNING: HOSTILE DAEMON DETECTED !!!", "warning");
        triggerDamageFlash(true);
        
        const alarmLoop = setInterval(() => { if(state.connected) AudioEngine.sfx.alarm(); }, 1000);
        let timeLeft = 6;
        state.watchdogInterval = setInterval(() => {
            if (!state.connected) {
                clearWatchdog(); clearInterval(alarmLoop); return;
            }
            timeLeft--;
            if (timeLeft <= 3) print(`TRACE COMPLETE IN: ${timeLeft}...`, "warning");
            if (timeLeft <= 0) {
                clearInterval(state.watchdogInterval); clearInterval(alarmLoop);
                state.stability = 0;
                print(">>> DAEMON LOCK ESTABLISHED.", "error");
                AudioEngine.sfx.glitch();
                commands.disconnect();
            }
        }, 1000);
        state.currentAlarmLoop = alarmLoop;
    }
    
    function clearWatchdog() {
        if (state.watchdogInterval) { clearInterval(state.watchdogInterval); state.watchdogInterval = null; }
        if (state.currentAlarmLoop) { clearInterval(state.currentAlarmLoop); state.currentAlarmLoop = null; }
        const overlay = document.getElementById('screen-overlay');
        overlay.className = '';
    }

    // --- COMMANDS ---

    const commands = {
        'help': () => {
            print("--- AVAILABLE COMMANDS ---", "system");
            print("ls          : List contents");
            print("cd [dir]    : Change directory");
            print("cat [fil]   : Read file");
            print("scan [fil]  : Identify MIMIC files");
            print("purge [f]   : Destroy CORRUPTION");
            print("decrypt [f] : Decrypt file (Minigame)");
            print("pay [amt]   : Pay Debt");
            print("connect [lv]: Start Job");
            print("disconnect  : Abort");
        },

        'clear': () => outputDiv.innerHTML = '',
        'abort': () => {
             if(state.activeAction) {
                 clearInterval(state.activeAction);
                 state.activeAction = null;
                 state.isBusy = false;
                 print("ACTION ABORTED.", "error");
                 updateHUD();
             }
        },

        'shop': (args) => {
            if (state.connected) return print("Shop unavailable remote.", "error");
            if (args.length === 0 || args[0] === 'list') {
                print("--- BLACK MARKET ---", "system");
                for (let [key, item] of Object.entries(SHOP_ITEMS)) {
                    // Check ownership for single-items, or show level for hardware
                    let status = "";
                    if (item.type === 'hardware') {
                        status = ` [LVL ${state.hardware[item.stat]}]`;
                    } else if (state.inventory.includes(key)) {
                        status = " [OWNED]";
                    }
                    print(`${key} : ${item.cost} CR : ${item.desc}${status}`);
                }
                return;
            }
            if (args[0] === 'buy') {
                const itemKey = args[1];
                if (!SHOP_ITEMS[itemKey]) return print("Item not found.", "error");
                const item = SHOP_ITEMS[itemKey];
                
                // Check dupes for non-hardware
                if (item.type !== 'hardware' && state.inventory.includes(itemKey)) {
                    return print("Item already owned.", "error");
                }

                if (state.credits >= item.cost) {
                    state.credits -= item.cost;
                    
                    if (item.type === 'hardware') {
                        state.hardware[item.stat]++;
                        state.updateStats(); // recalc max stats
                        print(`UPGRADE INSTALLED: ${item.stat.toUpperCase()} LVL ${state.hardware[item.stat]}`, "system");
                    } else {
                        state.inventory.push(itemKey);
                        print(`BOUGHT ${itemKey}.`, "system");
                    }
                    
                    state.save();
                    AudioEngine.sfx.success();
                    updateHUD();
                } else print(`INSUFFICIENT FUNDS.`, "error");
            }
        },

        'pay': (args) => {
            if (state.connected) return print("Bank unavailable remote.", "error");
            const amount = parseInt(args[0]);
            if (!amount || amount <= 0) return print("Usage: pay [amount]", "error");
            if (state.credits >= amount) {
                state.credits -= amount;
                state.debt = Math.max(0, state.debt - amount);
                state.save();
                AudioEngine.sfx.success();
                print(`PAID ${amount}. DEBT: ${state.debt}`, "system");
                if (state.debt === 0) {
                    AudioEngine.sfx.win();
                    print("CONTRACT FULFILLED. YOU ARE FREE.", "system");
                }
                updateHUD();
            } else print("INSUFFICIENT FUNDS.", "error");
        },

        'ls': () => {
            if (state.isBusy) return;
            const dir = getCurrentDir();
            const files = Object.keys(dir);
            if (files.length === 0) return print("(empty directory)");
            
            files.forEach(f => {
                let suffix = '';
                if (dir[f].type === 'dir') suffix = '/';
                else if (dir[f].type === 'exec') suffix = '*';
                
                let style = 'normal';
                if (dir[f].type === 'dir') style = 'file-dir';
                if (dir[f].type === 'exec') style = 'file-exec';
                
                let displayName = f;
                let extra = "";
                
                if (dir[f].locked) extra += " [LOCKED]";
                if (dir[f].encrypted) extra += " [ENCRYPTED]";
                
                if (dir[f].scanned) {
                    if (dir[f].isTrap) {
                        style = 'scanned-trap';
                        extra += " [TRAP]";
                    } else if (dir[f].isCorrupt) {
                        style = 'scanned-corrupt';
                        extra += " [TARGET]";
                    } else if (dir[f].type === 'file') {
                        style = 'scanned-safe';
                    }
                } else {
                    if (state.difficulty >= 2 && (dir[f].isTrap || dir[f].isCorrupt)) {
                        style = 'normal'; 
                    } else if (state.difficulty === 1 && dir[f].isCorrupt) {
                        style = 'error'; 
                    }
                }

                if (dir[f].hasWatchdog) style = 'watchdog-warning';

                print(displayName + suffix + extra, style);
            });
        },

        'cd': (args) => {
            if (state.isBusy) return;
            const rawTarget = args[0];
            if (!rawTarget) return print("Usage: cd [dir]", "error");
            
            if (rawTarget === "..") {
                if (state.currentPath.length > 0) {
                    clearWatchdog();
                    state.currentPath.pop();
                    if(state.currentPath.length === 0 && !state.connected) state.currentPath = ['home']; 
                    // AUTO-LS Trigger on Back
                    if (state.inventory.includes('root_kit')) setTimeout(() => commands.ls(), 50);
                }
            } else {
                const dir = getCurrentDir();
                const target = findFileKey(dir, rawTarget); 
                if (target && dir[target].type === 'dir') {
                    if (dir[target].locked) {
                        AudioEngine.sfx.error();
                        print(`LOCKED.`, "error");
                    } else {
                        clearWatchdog(); 
                        state.currentPath.push(target);
                        
                        // AUTO-LS Trigger
                        if (state.inventory.includes('root_kit')) setTimeout(() => commands.ls(), 50);

                        // SCANNER V2 CHECK (Auto-mark traps)
                        if (state.inventory.includes('scanner_v2')) {
                            const newDir = getCurrentDir(); // Get contents of new folder
                            let trapFound = false;
                            for (let key in newDir) {
                                if (newDir[key].isTrap) {
                                    newDir[key].scanned = true; // Mark it as scanned so ls shows it red
                                    trapFound = true;
                                }
                            }
                            if (trapFound) {
                                AudioEngine.sfx.error();
                                print(">> SCANNER V2: TRAP SIGNATURES DETECTED.", "warning");
                            }
                        }

                        if (dir[target].hasWatchdog) triggerWatchdog();
                    }
                } else {
                    AudioEngine.sfx.error();
                    print(`Not found.`, "error");
                }
            }
            updateHUD();
        },

        'cat': (args) => {
            if (state.isBusy) return;
            const rawTarget = args[0];
            if (!rawTarget) return print("Usage: cat [file]", "error");
            
            const dir = getCurrentDir();
            const target = findFileKey(dir, rawTarget); 

            if (target && dir[target].type === 'file') {
                print(`Opening ${target}...`, "system");
                print(dir[target].content);
            } else {
                AudioEngine.sfx.error();
                print("File not found or not readable.", "error");
            }
        },

        'scan': (args) => {
            if (!state.connected) return print("Remote only.", "error");
            const rawTarget = args[0];
            const dir = getCurrentDir();
            const target = findFileKey(dir, rawTarget);

            if (target && dir[target]) {
                const isInstant = state.currentTrait.instantScan;
                startAction("SCANNING", isInstant ? 0.1 : 2.0, () => {
                    if (dir[target]) {
                        dir[target].scanned = true;
                        if (dir[target].isTrap) print(`>> ALERT: ${target} IS A TRAP.`, "warning");
                        else if (dir[target].isCorrupt) print(`>> SUCCESS: ${target} IS THE TARGET.`, "system");
                        else if (dir[target].encrypted) print(`>> ENCRYPTED FILE.`, "system");
                        else print(`>> FILE INTEGRITY: NORMAL.`, "scanned-safe");
                    }
                });
            } else print("Target not found.", "error");
        },

        'decrypt': (args) => {
            if (!state.connected) return print("Remote only.", "error");
            const rawTarget = args[0];
            const dir = getCurrentDir();
            const target = findFileKey(dir, rawTarget);

            if (target && dir[target]) {
                if (dir[target].encrypted) {
                    if (state.inventory.includes('decryption_module')) {
                        startDecryptMinigame(state.difficulty, () => {
                            if (dir[target]) {
                                dir[target].encrypted = false;
                                print("ENCRYPTION BROKEN.", "system");
                            }
                        });
                    } else print("MISSING: decryption_module", "error");
                } else print("File not encrypted.", "system");
            } else print("Target not found.", "error");
        },

        'purge': (args) => {
            if (!state.connected) return print("Remote only.", "error");
            const rawTarget = args[0];
            const dir = getCurrentDir();
            const target = findFileKey(dir, rawTarget);
            
            if (target) {
                if (dir[target].encrypted) return print("ENCRYPTED. DECRYPT FIRST.", "error");
                
                if (!dir[target].scanned && state.difficulty >= 2) {
                    print("WARNING: TARGET UNSCANNED. PURGING BLINDLY...", "warning");
                }

                if (dir[target].isTrap) {
                    AudioEngine.sfx.glitch();
                    print("CRITICAL ERROR: TRAP TRIGGERED!", "error");
                    state.stability -= 50; 
                    triggerDamageFlash();
                    delete dir[target];
                    updateHUD();
                    return;
                }

                if (dir[target].isCorrupt) {
                     const costTime = 3.0 * state.currentTrait.purgeCost;
                     startAction("PURGING", costTime, () => {
                        const wasScanned = dir[target].scanned;
                        delete dir[target];
                        const reward = 50 * state.difficulty * (wasScanned ? 1 : 1.5);
                        state.credits += reward;
                        state.save();
                        AudioEngine.sfx.success();
                        print("TARGET ELIMINATED.", "system");
                        print(`EARNED: ${reward} CR`, "system");
                        clearInterval(state.timer);
                        setTimeout(() => commands.disconnect(), 2000);
                    });
                } else {
                    print("FILE IS STABLE. ABORTING.", "error");
                }
            } else print("Target not found.", "error");
        },

        'connect': (args) => {
            if (state.connected) return print("Already connected.", "error");
            if (state.isBusy) return;
            
            let targetLevel = args.length > 0 ? parseInt(args[0]) : null;
            AudioEngine.sfx.connect();
            print("INITIALIZING UPLINK...", "system");
            
            setTimeout(() => {
                state.connected = true;
                state.stability = 100;
                
                const themeKeys = Object.keys(THEMES);
                state.currentTheme = themeKeys[Math.floor(Math.random() * themeKeys.length)];
                setTheme(state.currentTheme);
                
                state.currentTrait = TRAITS[Math.floor(Math.random() * TRAITS.length)];
                print(`SERVER TRAIT: ${state.currentTrait.name} (${state.currentTrait.desc})`, "trait");

                if (!targetLevel) {
                     const roll = Math.random();
                     targetLevel = roll > 0.8 ? 3 : (roll > 0.4 ? 2 : 1);
                }
                state.difficulty = targetLevel;

                const themeData = THEMES[state.currentTheme];
                const needsEncryption = state.difficulty >= 2;
                const spawnWatchdog = state.difficulty >= 3 || (state.difficulty === 2 && Math.random() > 0.6 && state.currentTrait.name === 'GHOSTED');

                const depth = state.difficulty === 1 ? 0 : (state.difficulty === 2 ? 2 : 4);
                const serverRoot = {
                    type: "dir", 
                    content: generateDeepStructure(depth, themeData, state.difficulty)
                };

                const corruptName = state.difficulty >= 2 
                    ? themeData.decoys[Math.floor(Math.random()*themeData.decoys.length)] 
                    : `CORRUPT_${Math.floor(Math.random()*999)}.dat`;
                
                injectTargetIntoRandomFolder(serverRoot.content, corruptName, {
                    type: "file",
                    content: "I AM GROWING",
                    encrypted: needsEncryption,
                    isCorrupt: true,
                    isTrap: false
                });

                if (state.difficulty >= 2) {
                    for(let i=0; i<3; i++) {
                         const trapName = themeData.decoys[Math.floor(Math.random()*themeData.decoys.length)] + "_" + i;
                         injectTargetIntoRandomFolder(serverRoot.content, trapName, {
                             type: "file",
                             content: "TRAP",
                             isTrap: true,
                             isCorrupt: false
                         });
                    }
                }
                
                if (spawnWatchdog) {
                     injectTargetIntoRandomFolder(serverRoot.content, "sys", {
                         type: "dir", hasWatchdog: true, content: {}
                     });
                }

                state.fileSystem = { "root": serverRoot };
                state.currentPath = ["root"];
                
                print(`CONNECTED: ${state.currentTheme} (LVL ${state.difficulty})`, "system");
                updateHUD();
                startCorruptionLoop();
            }, 1000);
        },

        'disconnect': () => {
            if (!state.connected) return;
            if (state.activeAction) { clearInterval(state.activeAction); state.activeAction = null; state.isBusy = false; }
            clearInterval(state.timer);
            clearWatchdog();
            
            state.connected = false;
            setTheme(null);
            state.currentPath = ["home"];
            state.fileSystem = JSON.parse(JSON.stringify(FILESYSTEM_TEMPLATE));
            print("DISCONNECTED.", "system");
            updateHUD();
        }
    };

    // --- GAME LOOP ---
    function startCorruptionLoop() {
        state.timer = setInterval(() => {
            if (!state.connected) return;
            
            // Passive drain based on Trait + Difficulty
            let drain = 0.4 * state.difficulty * state.currentTrait.stabilityMod;
            if (state.inventory.includes('firewall_v1')) drain *= 0.5;
            
            // RAM REGEN (Passive)
            // If we have RAM upgrades, reduce drain slightly or even regenerate if drain is low
            const regen = state.hardware.ram * 0.1; 
            drain -= regen;
            
            state.stability -= drain;
            
            // Cap at max stability (RAM upgrade)
            if (state.stability > state.maxStability) state.stability = state.maxStability;

            if (state.stability <= 0) {
                AudioEngine.sfx.glitch();
                print("SYSTEM CRASH.", "error");
                triggerDamageFlash();
                if(state.activeAction) clearInterval(state.activeAction);
                commands.disconnect();
            }
            updateHUD();
        }, 1500);
    }

    // --- INPUT ---
    const commandHistory = [];
    let historyIndex = -1;

    inputField.addEventListener('keydown', (e) => {
        AudioEngine.init(); 

        if (state.minigameActive) {
            e.preventDefault();
            const char = e.key.toUpperCase();
            if ("0123456789ABCDEF".includes(char) && char.length === 1) {
                state.minigameInput += char;
                AudioEngine.sfx.minigameHit();
                updateMinigameUI();
                
                if (state.minigameInput === state.minigameTarget) {
                    endMinigame(true);
                } else if (state.minigameInput.length >= state.minigameTarget.length) {
                    state.minigameInput = ""; 
                    updateMinigameUI();
                }
            }
            return;
        }

        if (e.key === 'Tab') {
            e.preventDefault(); 
            const parts = inputField.value.split(' ');
            const lastWord = parts[parts.length-1].toLowerCase();

            if (parts.length >= 3 && parts[0].toLowerCase() === 'shop' && parts[1].toLowerCase() === 'buy') {
                 const match = Object.keys(SHOP_ITEMS).find(k => k.toLowerCase().startsWith(lastWord));
                 if (match) {
                     parts[parts.length-1] = match;
                     inputField.value = parts.join(' ');
                     AudioEngine.sfx.type();
                 }
                 return;
            }

            if (parts.length === 1) {
                const match = Object.keys(commands).find(c => c.startsWith(lastWord));
                if (match) inputField.value = match + " ";
            } else {
                const dir = getCurrentDir();
                const match = Object.keys(dir).find(f => f.toLowerCase().startsWith(lastWord));
                if (match) { parts[parts.length-1] = match; inputField.value = parts.join(' '); }
            }
            return;
        }
        if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
            e.preventDefault();
            if (e.key === 'ArrowUp' && historyIndex < commandHistory.length - 1) historyIndex++;
            else if (e.key === 'ArrowDown' && historyIndex > -1) historyIndex--;
            
            if (historyIndex === -1) inputField.value = "";
            else inputField.value = commandHistory[commandHistory.length - 1 - historyIndex];
            return;
        }

        if (e.key === 'Enter') {
            const raw = inputField.value.trim();
            if (!raw) return;
            if (state.isBusy && raw !== 'abort') return; 

            commandHistory.push(raw);
            historyIndex = -1;
            
            print(`user: ${raw}`);
            const parts = raw.split(/\s+/);
            const cmd = parts[0].toLowerCase();
            const args = parts.slice(1);

            if (commands[cmd]) {
                if (state.connected && cmd !== 'abort') {
                    // Action Cost reduced by NET Card
                    let cost = 1.0 * state.difficulty;
                    // Net card reduction: 10% per level
                    const netBonus = Math.min(0.5, state.hardware.net * 0.1); 
                    cost *= (1.0 - netBonus);
                    
                    state.stability -= cost;
                    triggerDamageFlash();
                    if(state.stability <= 0) {
                        commands.disconnect(); 
                        return;
                    }
                }
                commands[cmd](args);
            } else print(`Unknown: ${cmd}`, "error");
            
            inputField.value = '';
            updateHUD();
        } else {
            AudioEngine.sfx.type();
        }
    });

    window.onload = () => {
        print("BOOTING ROOT_ACCESS v0.9...", "system");
        setTimeout(() => print("LOADING...", "system"), 500);
        setTimeout(() => {
            print("READY.", "system");
            print("Type 'help' to start.", "system");
            inputField.focus();
        }, 1000);
        document.addEventListener('click', () => { inputField.focus(); AudioEngine.init(); });
    };

</script>
</body>
</html>
